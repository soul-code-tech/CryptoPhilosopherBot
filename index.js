const express = require('express');
const cors = require('cors');
const path = require('path');
const axios = require('axios');
const CryptoJS = require('crypto-js');
const moment = require('moment');

// ==========================
// –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
// ==========================
let globalState = {
  balance: 100, // –î–µ–º–æ-–±–∞–ª–∞–Ω—Å
  realBalance: null, // –†–µ–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å —Å BingX Futures
  positions: {}, // –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
  history: [], // –ò—Å—Ç–æ—Ä–∏—è –í–°–ï–• —Å–¥–µ–ª–æ–∫
  stats: {
    totalTrades: 0,
    profitableTrades: 0,
    losingTrades: 0,
    winRate: 0,
    totalProfit: 0,
    maxDrawdown: 0,
    peakBalance: 100,
    maxLeverageUsed: 1,
    volatilityIndex: 0,
    marketSentiment: 50
  },
  marketMemory: {
    lastTrades: {},
    consecutiveTrades: {},
    volatilityHistory: {},
    fearSentimentHistory: [],
    marketNews: [],
    fundamentalData: {} // –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –º–æ–Ω–µ—Ç
  },
  isRunning: true,
  takerFee: 0.0005, // –ö–æ–º–∏—Å—Å–∏—è —Ç–µ–π–∫–µ—Ä–∞ (0.05%)
  makerFee: 0.0002, // –ö–æ–º–∏—Å—Å–∏—è –º–µ–π–∫–µ—Ä–∞ (0.02%)
  maxRiskPerTrade: 0.01,  // 1% –æ—Ç –¥–µ–ø–æ–∑–∏—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  maxLeverage: 3,         // 3x –ø–ª–µ—á–æ
  watchlist: [
    { symbol: 'BTC', name: 'bitcoin' },
    { symbol: 'ETH', name: 'ethereum' },
    { symbol: 'SOL', name: 'solana' },
    { symbol: 'XRP', name: 'ripple' }
  ],
  isRealMode: false, // false = –¥–µ–º–æ, true = —Ä–µ–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
  tradeMode: 'adaptive', // 'adaptive' (–∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º), 'scalping', 'swing'
  riskLevel: 'recommended', // 'recommended', 'medium', 'high', 'extreme'
  testMode: false,
  currentPrices: {},
  fearIndex: 50,
  binanceApiKey: process.env.BINGX_API_KEY,
  binanceSecretKey: process.env.BINGX_SECRET_KEY,
  bingxFuturesUrl: 'https://open-api.bingx.com'
};

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö –º–æ–Ω–µ—Ç
globalState.watchlist.forEach(coin => {
  globalState.positions[coin.name] = null;
  globalState.marketMemory.lastTrades[coin.name] = [];
  globalState.marketMemory.consecutiveTrades[coin.name] = 0;
  globalState.marketMemory.volatilityHistory[coin.name] = [];
  globalState.marketMemory.fundamentalData[coin.name] = {
    hashRate: null,
    activeAddresses: null,
    transactions: null,
    developerActivity: null,
    socialSentiment: null
  };
});

// ==========================
// –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø BINGX API
// ==========================
const BINGX_API_KEY = process.env.BINGX_API_KEY;
const BINGX_SECRET_KEY = process.env.BINGX_SECRET_KEY;
const BINGX_FUTURES_URL = 'https://open-api.bingx.com';

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è BingX (–°–¢–†–û–ì–û –ü–û –î–û–ö–£–ú–ï–ù–¢–ê–¶–ò–ò)
// ==========================
function signBingXRequest(params) {
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ –∫–ª—é—á–∞–º
  const sortedKeys = Object.keys(params).sort();
  const sortedParams = sortedKeys.map(key => `${key}=${params[key]}`).join('&');
  // –°–æ–∑–¥–∞–µ–º –ø–æ–¥–ø–∏—Å—å HMAC SHA256
  return CryptoJS.HmacSHA256(sortedParams, BINGX_SECRET_KEY).toString(CryptoJS.enc.Hex);
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ Fear & Greed Index
// ==========================
async function getFearAndGreedIndex() {
  try {
    const response = await axios.get('https://api.alternative.me/fng/?limit=1', { timeout: 10000 });
    const value = parseInt(response.data.data[0].value);
    globalState.marketMemory.fearSentimentHistory.push({ value, timestamp: Date.now() });
    if (globalState.marketMemory.fearSentimentHistory.length > 24) {
      globalState.marketMemory.fearSentimentHistory.shift();
    }
    globalState.fearIndex = value;
    globalState.stats.marketSentiment = value;
    return value;
  } catch (e) {
    console.log('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω–¥–µ–∫—Å —Å—Ç—Ä–∞—Ö–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º 50');
    globalState.fearIndex = Math.floor(20 + Math.random() * 60); // –°–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 20 –¥–æ 80
    globalState.stats.marketSentiment = globalState.fearIndex;
    return globalState.fearIndex;
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ —Å BingX Futures
// ==========================
async function getBingXRealBalance() {
  try {
    console.log('üîç [–ë–ê–õ–ê–ù–°] –ù–∞—á–∏–Ω–∞—é –∑–∞–ø—Ä–æ—Å —Ä–µ–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞...');
    if (!BINGX_API_KEY || !BINGX_SECRET_KEY) {
      console.error('‚ùå [–ë–ê–õ–ê–ù–°] API-–∫–ª—é—á–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
      return null;
    }
    const timestamp = Date.now();
    const params = { timestamp };
    const signature = signBingXRequest(params);
    // –í–ê–ñ–ù–û: –í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ query string, –∞ –Ω–µ –≤ body
    const url = `${BINGX_FUTURES_URL}/openApi/swap/v2/user/balance?timestamp=${timestamp}&signature=${signature}`;
    console.log('üåê [–ë–ê–õ–ê–ù–°] –û—Ç–ø—Ä–∞–≤–ª—è—é –ü–û–î–ü–ò–°–ê–ù–ù–´–ô –∑–∞–ø—Ä–æ—Å –∫:', url);
    const response = await axios.get(url, {
      headers: { 
        'X-BX-APIKEY': BINGX_API_KEY,
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      },
      timeout: 10000
    });
    console.log('‚úÖ [–ë–ê–õ–ê–ù–°] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç BingX:', JSON.stringify(response.data, null, 2));
    if (response.data.code === 0 && response.data.data) {
      let usdtBalance = null;
      // –í–ê–†–ò–ê–ù–¢ 1: BingX –≤–µ—Ä–Ω—É–ª {  { balance: { asset: 'USDT', balance: '0.5384' } } }
      if (response.data.data.balance && response.data.data.balance.asset === 'USDT') {
        usdtBalance = parseFloat(response.data.data.balance.balance);
        console.log(`üí∞ [–ë–ê–õ–ê–ù–°] –ù–∞–π–¥–µ–Ω –±–∞–ª–∞–Ω—Å –≤ data.balance: $${usdtBalance.toFixed(2)}`);
      }
      // –í–ê–†–ò–ê–ù–¢ 2: BingX –≤–µ—Ä–Ω—É–ª {  { assets: [...] } }
      else if (response.data.data.assets && Array.isArray(response.data.data.assets)) {
        const usdtAsset = response.data.data.assets.find(asset => asset.asset === 'USDT');
        if (usdtAsset && usdtAsset.walletBalance) {
          usdtBalance = parseFloat(usdtAsset.walletBalance);
          console.log(`üí∞ [–ë–ê–õ–ê–ù–°] –ù–∞–π–¥–µ–Ω –±–∞–ª–∞–Ω—Å –≤ assets: $${usdtBalance.toFixed(2)}`);
        }
      }
      // –í–ê–†–ò–ê–ù–¢ 3: BingX –≤–µ—Ä–Ω—É–ª {  [...] } (–º–∞—Å—Å–∏–≤)
      else if (Array.isArray(response.data.data)) {
        const assetsArray = response.data.data;
        const usdtAsset = assetsArray.find(asset => asset.asset === 'USDT');
        if (usdtAsset && usdtAsset.walletBalance) {
          usdtBalance = parseFloat(usdtAsset.walletBalance);
          console.log(`üí∞ [–ë–ê–õ–ê–ù–°] –ù–∞–π–¥–µ–Ω –±–∞–ª–∞–Ω—Å –≤ –º–∞—Å—Å–∏–≤–µ  $${usdtBalance.toFixed(2)}`);
        }
      }
      if (usdtBalance !== null) {
        return usdtBalance;
      } else {
        console.error('‚ùå [–ë–ê–õ–ê–ù–°] –ù–µ –Ω–∞–π–¥–µ–Ω –±–∞–ª–∞–Ω—Å USDT –≤ –æ—Ç–≤–µ—Ç–µ');
      }
    } else {
      console.error('‚ùå [–ë–ê–õ–ê–ù–°] –û—à–∏–±–∫–∞ –≤ –æ—Ç–≤–µ—Ç–µ –æ—Ç BingX:', response.data.msg || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
    }
    return null;
  } catch (error) {
    console.error('‚ùå [–ë–ê–õ–ê–ù–°] –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞:', error.message);
    return null;
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö —Å–≤–µ—á–µ–π —Å BingX Futures (–ò–°–ü–†–ê–í–õ–ï–ù–ê)
// ==========================
async function getBingXFuturesHistory(symbol, interval = '1h', limit = 100) {
  try {
    const params = {
      symbol: `${symbol}USDT`,
      interval,
      limit
    };
    const timestamp = Date.now();
    params.timestamp = timestamp;
    const signature = signBingXRequest(params);
    // –í–ê–ñ–ù–û: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –¢–ï–õ–ï POST-–∑–∞–ø—Ä–æ—Å–∞, –∞ –Ω–µ –≤ query string!
    const url = `${BINGX_FUTURES_URL}/openApi/swap/v2/quote/klines`;
    console.log(`üåê –ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è ${symbol}: POST ${url}`);
    const response = await axios.post(url, params, { // <-- –ò—Å–ø–æ–ª—å–∑—É–µ–º POST –∏ –ø–µ—Ä–µ–¥–∞–µ–º params –≤ —Ç–µ–ª–æ
      headers: { 
        'X-BX-APIKEY': BINGX_API_KEY,
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      },
      timeout: 10000
    });
    console.log('‚úÖ [–ò–°–¢–û–†–ò–Ø] –û—Ç–≤–µ—Ç:', JSON.stringify(response.data, null, 2));
    if (response.data.code === 0 && Array.isArray(response.data.data)) {
      const candles = response.data.data.map(candle => ({
        time: candle[0],
        open: parseFloat(candle[1]),
        high: parseFloat(candle[2]),
        low: parseFloat(candle[3]),
        close: parseFloat(candle[4]),
        volume: parseFloat(candle[5]),
        closeTime: candle[6],
        quoteVolume: parseFloat(candle[7]),
        trades: parseInt(candle[8]),
        takerBuyBaseVolume: parseFloat(candle[9]),
        takerBuyQuoteVolume: parseFloat(candle[10])
      }));
      return candles;
    } else {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –≤ –æ—Ç–≤–µ—Ç–µ –æ—Ç BingX –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ ${symbol}:`, response.data.msg || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
      return [];
    }
  } catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è ${symbol}:`, error.message);
    return [];
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–Ω —Å BingX (–ò–°–ü–†–ê–í–õ–ï–ù–ê)
// ==========================
async function getCurrentPrices() {
  try {
    const symbols = globalState.watchlist.map(coin => coin.symbol).join(',');
    const params = {
      symbols
    };
    const timestamp = Date.now();
    params.timestamp = timestamp;
    const signature = signBingXRequest(params);
    // –í–ê–ñ–ù–û: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –¢–ï–õ–ï POST-–∑–∞–ø—Ä–æ—Å–∞
    const url = `${BINGX_FUTURES_URL}/openApi/swap/v2/quote/ticker/price`;
    console.log(`üåê –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–Ω: POST ${url}`);
    const response = await axios.post(url, params, { // <-- –ò—Å–ø–æ–ª—å–∑—É–µ–º POST
      headers: { 
        'X-BX-APIKEY': BINGX_API_KEY,
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      },
      timeout: 10000
    });
    console.log('‚úÖ [–¶–ï–ù–´] –û—Ç–≤–µ—Ç:', JSON.stringify(response.data, null, 2));
    if (response.data.code === 0 && Array.isArray(response.data.data)) {
      const prices = {};
      response.data.data.forEach(item => {
        const symbol = item.symbol.replace('USDT', '').toLowerCase();
        prices[symbol] = parseFloat(item.price);
      });
      globalState.currentPrices = prices;
      return prices;
    } else {
      console.error('‚ùå –û—à–∏–±–∫–∞ –≤ –æ—Ç–≤–µ—Ç–µ –æ—Ç BingX –¥–ª—è —Ü–µ–Ω:', response.data.msg || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
      return {};
    }
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–∏—Ö —Ü–µ–Ω:', error.message);
    return {};
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–µ—á–∞ –¥–ª—è —Ñ—å—é—á–µ—Ä—Å–æ–≤
// ==========================
async function setBingXLeverage(symbol, leverage) {
  try {
    if (!BINGX_API_KEY || !BINGX_SECRET_KEY) {
      console.log(`‚ÑπÔ∏è [–ü–õ–ï–ß–û] API-–∫–ª—é—á–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã. –ü–ª–µ—á–æ ${leverage}x –¥–ª—è ${symbol} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ.`);
      return true;
    }
    const timestamp = Date.now();
    const params = {
      symbol: `${symbol}USDT`,
      side: 'LONG',
      leverage: leverage.toString(),
      timestamp: timestamp
    };
    const signature = signBingXRequest(params);
    const url = `${BINGX_FUTURES_URL}/openApi/swap/v2/trade/leverage?symbol=${params.symbol}&side=LONG&leverage=${params.leverage}&timestamp=${params.timestamp}&signature=${signature}`;
    const response = await axios.post(url, null, {
      headers: { 
        'X-BX-APIKEY': BINGX_API_KEY,
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      },
      timeout: 10000
    });
    if (response.data.code === 0) {
      console.log(`‚úÖ –ü–ª–µ—á–æ ${leverage}x —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è ${symbol}`);
      return true;
    } else {
      console.error(`‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞ –¥–ª—è ${symbol}:`, response.data.msg);
      return false;
    }
  } catch (error) {
    console.error(`üí• –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞:`, error.message);
    return false;
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –†–∞–∑–º–µ—â–µ–Ω–∏–µ —Ñ—å—é—á–µ—Ä—Å–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
// ==========================
async function placeBingXFuturesOrder(symbol, side, type, quantity, price = null, leverage) {
  try {
    if (!BINGX_API_KEY || !BINGX_SECRET_KEY) {
      console.log(`‚ÑπÔ∏è [–û–†–î–ï–†] API-–∫–ª—é—á–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã. –û—Ä–¥–µ—Ä ${side} ${quantity} ${symbol} —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω.`);
      return { orderId: `fake_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` };
    }
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–µ—á–æ
    const leverageSet = await setBingXLeverage(symbol, leverage);
    if (!leverageSet) {
      console.log(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ ${leverage}x –¥–ª—è ${symbol}`);
      return null;
    }
    const timestamp = Date.now();
    const params = {
      symbol: `${symbol}USDT`,
      side: side,
      type: type,
      quantity: quantity.toFixed(6),
      timestamp: timestamp
    };
    // –î–ª—è –ª–∏–º–∏—Ç–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤ –¥–æ–±–∞–≤–ª—è–µ–º —Ü–µ–Ω—É
    if (price && type === 'LIMIT') {
      params.price = price.toFixed(8);
    }
    const signature = signBingXRequest(params);
    let url = `${BINGX_FUTURES_URL}/openApi/swap/v2/trade/order?symbol=${params.symbol}&side=${params.side}&type=${params.type}&quantity=${params.quantity}&timestamp=${params.timestamp}&signature=${signature}`;
    if (price && type === 'LIMIT') {
      url += `&price=${price.toFixed(8)}`;
    }
    const response = await axios.post(url, null, {
      headers: { 
        'X-BX-APIKEY': BINGX_API_KEY,
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      },
      timeout: 10000
    });
    if (response.data.code === 0) {
      console.log(`‚úÖ –£–°–ü–ï–®–ù–´–ô –û–†–î–ï–†: ${side} ${quantity} ${symbol}`);
      return response.data.data;
    } else {
      console.error(`‚ùå –û–®–ò–ë–ö–ê –û–†–î–ï–†–ê:`, response.data.msg);
      return null;
    }
  } catch (error) {
    console.error(`üí• –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ –æ—Ä–¥–µ—Ä–∞:`, error.message);
    return null;
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –û—Ç–∫—Ä—ã—Ç–∏–µ —Ñ—å—é—á–µ—Ä—Å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
// ==========================
async function openFuturesTrade(coin, direction, leverage, size, price, stopLoss, takeProfit) {
  const symbol = coin.toUpperCase();
  console.log(`üåê –û—Ç–ø—Ä–∞–≤–∫–∞ ${direction} –æ—Ä–¥–µ—Ä–∞ –Ω–∞ BingX Futures: ${size} ${symbol} —Å –ø–ª–µ—á–æ–º ${leverage}x`);
  console.log(`üîÑ –¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º: ${globalState.isRealMode ? '–†–ï–ê–õ–¨–ù–´–ô' : '–î–ï–ú–û'}`);
  console.log(`‚ö° –¢–æ—Ä–≥–æ–≤—ã–π —Ä–µ–∂–∏–º: ${globalState.tradeMode}`);
  console.log(`üí£ –£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: ${globalState.riskLevel}`);
  if (globalState.isRealMode) {
    const result = await placeBingXFuturesOrder(symbol, direction === 'LONG' ? 'BUY' : 'SELL', 'MARKET', size, null, leverage);
    if (result) {
      const fee = size * price * globalState.takerFee; // –ö–æ–º–∏—Å—Å–∏—è —Ç–µ–π–∫–µ—Ä–∞
      const trade = {
        coin,
        type: direction,
        size,
        entryPrice: price,
        currentPrice: price,
        leverage,
        stopLoss,
        takeProfit,
        fee,
        timestamp: new Date().toLocaleString(),
        status: 'OPEN',
        orderId: result.orderId,
        progress: 0,
        probability: 50,
        riskScore: calculateRiskScore(coin)
      };
      globalState.history.push(trade);
      globalState.positions[coin] = trade;
      globalState.stats.totalTrades++;
      globalState.marketMemory.consecutiveTrades[coin] = (globalState.marketMemory.consecutiveTrades[coin] || 0) + 1;
      globalState.stats.maxLeverageUsed = Math.max(globalState.stats.maxLeverageUsed, leverage);
      console.log(`‚úÖ –£–°–ü–ï–®–ù–û: ${direction} ${size} ${coin} –Ω–∞ BingX Futures`);
      return true;
    } else {
      console.log(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –æ—Ä–¥–µ—Ä –Ω–∞ BingX Futures`);
      return false;
    }
  } else {
    const cost = (size * price) / leverage;
    const fee = size * price * globalState.takerFee;
    if (cost + fee > globalState.balance * globalState.maxRiskPerTrade) {
      console.log(`‚ùå –†–∏—Å–∫ –ø—Ä–µ–≤—ã—à–∞–µ—Ç ${globalState.maxRiskPerTrade * 100}% –æ—Ç –¥–µ–ø–æ–∑–∏—Ç–∞`);
      return false;
    }
    globalState.balance -= fee;
    const trade = {
      coin,
      type: direction,
      size,
      entryPrice: price,
      currentPrice: price,
      leverage,
      stopLoss,
      takeProfit,
      fee,
      timestamp: new Date().toLocaleString(),
      status: 'OPEN',
      progress: 0,
      probability: 50,
      riskScore: calculateRiskScore(coin)
    };
    globalState.history.push(trade);
    globalState.positions[coin] = trade;
    globalState.stats.totalTrades++;
    globalState.marketMemory.consecutiveTrades[coin] = (globalState.marketMemory.consecutiveTrades[coin] || 0) + 1;
    globalState.stats.maxLeverageUsed = Math.max(globalState.stats.maxLeverageUsed, leverage);
    console.log(`‚úÖ –î–ï–ú–û: ${direction} ${size} ${coin} —Å –ø–ª–µ—á–æ–º ${leverage}x`);
    return true;
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –†–∞—Å—á–µ—Ç —Ä–∏—Å–∫–æ–≤–æ–π –æ—Ü–µ–Ω–∫–∏ –¥–ª—è –º–æ–Ω–µ—Ç—ã
// ==========================
function calculateRiskScore(coin) {
  const fundamentalData = globalState.marketMemory.fundamentalData[coin];
  const volatility = globalState.marketMemory.volatilityHistory[coin][globalState.marketMemory.volatilityHistory[coin].length - 1] || 0.02;
  // –ë–∞–∑–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞ —Ä–∏—Å–∫–∞ (0-100)
  let riskScore = 50;
  // –£—á–∏—Ç—ã–≤–∞–µ–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
  if (volatility > 0.05) riskScore += 20;
  if (volatility < 0.02) riskScore -= 10;
  // –£—á–∏—Ç—ã–≤–∞–µ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
  if (fundamentalData && fundamentalData.developerActivity) {
    if (fundamentalData.developerActivity > 100) riskScore -= 15; // –ú–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ - –º–µ–Ω—å—à–µ —Ä–∏—Å–∫
    else if (fundamentalData.developerActivity < 20) riskScore += 25; // –ú–∞–ª–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ - –±–æ–ª—å—à–µ —Ä–∏—Å–∫
  }
  // –£—á–∏—Ç—ã–≤–∞–µ–º Fear & Greed Index
  if (globalState.fearIndex < 30) riskScore -= 15; // –°—Ç—Ä–∞—Ö - –º–µ–Ω—å—à–µ —Ä–∏—Å–∫ –¥–ª—è LONG
  else if (globalState.fearIndex > 70) riskScore += 15; // –ñ–∞–¥–Ω–æ—Å—Ç—å - –±–æ–ª—å—à–µ —Ä–∏—Å–∫
  return Math.max(0, Math.min(100, riskScore));
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –£–ù–ò–ö–ê–õ–¨–ù–´–ô –ê–î–ê–ü–¢–ò–í–ù–´–ô –ê–ù–ê–õ–ò–ó
// ==========================
function analyzeMarketWithAdaptiveStrategy(candles, coinName, currentFearIndex, fundamentalData) {
  if (candles.length < 50) return null;
  const prices = candles.map(c => c.close);
  const currentPrice = prices[prices.length - 1];
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
  const sma20 = calculateSMA(prices, 20);
  const sma50 = calculateSMA(prices, 50);
  const sma200 = calculateSMA(prices, 200);
  const atr = calculateATR(candles.slice(-14));
  const rsi = calculateRSI(prices.slice(-14));
  const bollingerUpper = calculateBollingerBands(prices, 20, 2).upper;
  const bollingerLower = calculateBollingerBands(prices, 20, 2).lower;
  const macd = calculateMACD(prices);
  const ichimoku = calculateIchimokuCloud(candles);
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
  const volatility = atr / currentPrice;
  const isHighVolatility = volatility > 0.05;
  const isLowVolatility = volatility < 0.02;
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç—Ä–µ–Ω–¥
  const isUptrend = sma20 > sma50 && sma50 > sma200;
  const isDowntrend = sma20 < sma50 && sma50 < sma200;
  const isSideways = Math.abs(sma20 - sma50) / sma20 < 0.01;
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å/–ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å
  const isOverbought = rsi > 70;
  const isOversold = rsi < 30;
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º MACD —Å–∏–≥–Ω–∞–ª
  const isMACDBullish = macd.macd > macd.signal;
  const isMACDBearish = macd.macd < macd.signal;
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º Ichimoku Cloud
  const isIchimokuBullish = currentPrice > ichimoku.senkouSpanA && currentPrice > ichimoku.senkouSpanB;
  const isIchimokuBearish = currentPrice < ichimoku.senkouSpanA && currentPrice < ichimoku.senkouSpanB;
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º Bollinger Bands
  const isBollingerUpperBreak = currentPrice > bollingerUpper;
  const isBollingerLowerBreak = currentPrice < bollingerLower;
  const isBollingerSqueeze = (bollingerUpper - bollingerLower) / sma20 < 0.01;
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—É—é –æ—Ü–µ–Ω–∫—É
  const fundamentalScore = fundamentalData ? calculateFundamentalScore(fundamentalData) : 50;
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â—É—é –æ—Ü–µ–Ω–∫—É —Ä—ã–Ω–∫–∞
  const marketSentiment = calculateMarketSentiment(currentFearIndex, fundamentalScore);
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∏–≥–Ω–∞–ª
  let signal = {
    direction: null,
    confidence: 0.5,
    leverage: 1,
    reasoning: [],
    stopLoss: null,
    takeProfit: null,
    riskScore: 50
  };
  // –ë–∞–∑–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
  if (isUptrend && isMACDBullish && isIchimokuBullish && !isOverbought) {
    signal.direction = 'LONG';
    signal.confidence += 0.3;
    signal.reasoning.push("üìà –¢—Ä–µ–Ω–¥ –≤–≤–µ—Ä—Ö + MACD –±—ã—á–∏–π + Ichimoku –±—ã—á–∏–π");
  }
  if (isDowntrend && isMACDBearish && isIchimokuBearish && !isOversold) {
    signal.direction = 'SHORT';
    signal.confidence += 0.3;
    signal.reasoning.push("üìâ –¢—Ä–µ–Ω–¥ –≤–Ω–∏–∑ + MACD –º–µ–¥–≤–µ–∂–∏–π + Ichimoku –º–µ–¥–≤–µ–∂–∏–π");
  }
  if (isBollingerSqueeze && isUptrend) {
    signal.direction = 'LONG';
    signal.confidence += 0.2;
    signal.reasoning.push("üìä –°–∂–∞—Ç–∏–µ Bollinger Bands + –≤–æ—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥ ‚Üí –æ–∂–∏–¥–∞–µ—Ç—Å—è –ø—Ä–æ—Ä—ã–≤");
  }
  if (isBollingerSqueeze && isDowntrend) {
    signal.direction = 'SHORT';
    signal.confidence += 0.2;
    signal.reasoning.push("üìä –°–∂–∞—Ç–∏–µ Bollinger Bands + –Ω–∏—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥ ‚Üí –æ–∂–∏–¥–∞–µ—Ç—Å—è –ø—Ä–æ—Ä—ã–≤");
  }
  if (isBollingerUpperBreak && isUptrend) {
    signal.direction = 'LONG';
    signal.confidence += 0.2;
    signal.reasoning.push("üéØ –ü—Ä–æ—Ä—ã–≤ –≤–µ—Ä—Ö–Ω–µ–π –ø–æ–ª–æ—Å—ã Bollinger + –≤–æ—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥");
  }
  if (isBollingerLowerBreak && isDowntrend) {
    signal.direction = 'SHORT';
    signal.confidence += 0.2;
    signal.reasoning.push("üéØ –ü—Ä–æ—Ä—ã–≤ –Ω–∏–∂–Ω–µ–π –ø–æ–ª–æ—Å—ã Bollinger + –Ω–∏—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥");
  }
  // –£—á–∏—Ç—ã–≤–∞–µ–º Fear & Greed Index
  if (currentFearIndex < 25 && signal.direction === 'LONG') {
    signal.confidence += 0.15;
    signal.reasoning.push("üò± –°–∏–ª—å–Ω—ã–π —Å—Ç—Ä–∞—Ö + –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å ‚Üí –æ—Ç–ª–∏—á–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è LONG");
  }
  if (currentFearIndex > 75 && signal.direction === 'SHORT') {
    signal.confidence += 0.15;
    signal.reasoning.push("ü§ë –°–∏–ª—å–Ω–∞—è –∂–∞–¥–Ω–æ—Å—Ç—å + –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å ‚Üí –æ—Ç–ª–∏—á–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è SHORT");
  }
  // –£—á–∏—Ç—ã–≤–∞–µ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—É—é –æ—Ü–µ–Ω–∫—É
  if (fundamentalScore > 70 && signal.direction === 'LONG') {
    signal.confidence += 0.1;
    signal.reasoning.push("üìä –í—ã—Å–æ–∫–∞—è —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ ‚Üí –ø–æ–¥–¥–µ—Ä–∂–∫–∞ LONG");
  }
  if (fundamentalScore < 30 && signal.direction === 'SHORT') {
    signal.confidence += 0.1;
    signal.reasoning.push("üìä –ù–∏–∑–∫–∞—è —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ ‚Üí –ø–æ–¥–¥–µ—Ä–∂–∫–∞ SHORT");
  }
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∏—Å–∫-—Å–∫–æ—Ä
  signal.riskScore = calculateRiskScore(coinName);
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–æ–ø-–ª–æ—Å—Å –∏ —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
  const atrMultiplier = isHighVolatility ? 2.5 : 1.5;
  const volatilityFactor = isLowVolatility ? 0.8 : 1.2;
  if (signal.direction === 'LONG') {
    signal.stopLoss = currentPrice * (1 - (atr * atrMultiplier / currentPrice));
    signal.takeProfit = currentPrice * (1 + (atr * atrMultiplier * 2 / currentPrice));
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø–ª–µ—á–æ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
    if (isHighVolatility) {
      signal.leverage = Math.min(3, globalState.maxLeverage * 0.5);
      signal.reasoning.push("‚ö†Ô∏è –í—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å ‚Üí —Å–Ω–∏–∂–∞–µ–º –ø–ª–µ—á–æ");
    } else if (isLowVolatility) {
      signal.leverage = Math.min(10, globalState.maxLeverage * 1.5);
      signal.reasoning.push("üìâ –ù–∏–∑–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–ª–µ—á–æ");
    } else {
      signal.leverage = globalState.maxLeverage;
    }
    // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç
    signal.stopLoss = currentPrice * (1 - (volatility * volatilityFactor * 3));
    signal.takeProfit = currentPrice * (1 + (volatility * volatilityFactor * 6));
  } else if (signal.direction === 'SHORT') {
    signal.stopLoss = currentPrice * (1 + (atr * atrMultiplier / currentPrice));
    signal.takeProfit = currentPrice * (1 - (atr * atrMultiplier * 2 / currentPrice));
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø–ª–µ—á–æ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
    if (isHighVolatility) {
      signal.leverage = Math.min(3, globalState.maxLeverage * 0.5);
      signal.reasoning.push("‚ö†Ô∏è –í—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å ‚Üí —Å–Ω–∏–∂–∞–µ–º –ø–ª–µ—á–æ");
    } else if (isLowVolatility) {
      signal.leverage = Math.min(10, globalState.maxLeverage * 1.5);
      signal.reasoning.push("üìâ –ù–∏–∑–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–ª–µ—á–æ");
    } else {
      signal.leverage = globalState.maxLeverage;
    }
    // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç
    signal.stopLoss = currentPrice * (1 + (volatility * volatilityFactor * 3));
    signal.takeProfit = currentPrice * (1 - (volatility * volatilityFactor * 6));
  }
  // –£—á–∏—Ç—ã–≤–∞–µ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—É—é –æ—Ü–µ–Ω–∫—É –≤ —Ä–∏—Å–∫–µ
  if (signal.riskScore > 70) {
    signal.confidence *= 0.8;
    signal.reasoning.push("‚ö†Ô∏è –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫-—Å–∫–æ—Ä ‚Üí —Å–Ω–∏–∂–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å");
  } else if (signal.riskScore < 30) {
    signal.confidence *= 1.2;
    signal.reasoning.push("‚úÖ –ù–∏–∑–∫–∏–π —Ä–∏—Å–∫-—Å–∫–æ—Ä ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å");
  }
  signal.reasoning.push(`üìä –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: ${volatility.toFixed(4)} (${isHighVolatility ? '–í—ã—Å–æ–∫–∞—è' : isLowVolatility ? '–ù–∏–∑–∫–∞—è' : '–°—Ä–µ–¥–Ω—è—è'})`);
  signal.reasoning.push(`üìà –†—ã–Ω–æ—á–Ω—ã–π —Ç—Ä–µ–Ω–¥: ${isUptrend ? '–í–æ—Å—Ö–æ–¥—è—â–∏–π' : isDowntrend ? '–ù–∏—Å—Ö–æ–¥—è—â–∏–π' : '–ë–æ–∫–æ–≤–æ–π'}`);
  signal.reasoning.push(`üß† –†—ã–Ω–æ—á–Ω—ã–π sentiment: ${marketSentiment.toFixed(0)}%`);
  signal.reasoning.push(`üîç –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞: ${fundamentalScore.toFixed(0)}/100`);
  signal.reasoning.push(`‚ö†Ô∏è –†–∏—Å–∫-—Å–∫–æ—Ä: ${signal.riskScore.toFixed(0)}/100`);
  return {
    coin: coinName,
    currentPrice,
    signal,
    rsi,
    volatility,
    sma20,
    sma50,
    sma200,
    atr,
    bollingerUpper,
    bollingerLower,
    macd,
    ichimoku,
    marketSentiment,
    fundamentalScore
  };
}

// ==========================
// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
// ==========================
function calculateSMA(prices, period) {
  if (prices.length < period) return 0;
  return prices.slice(-period).reduce((a, b) => a + b, 0) / period;
}
function calculateATR(candles) {
  let trSum = 0;
  for (let i = 1; i < candles.length; i++) {
    const tr = Math.max(
      candles[i].high - candles[i].low,
      Math.abs(candles[i].high - candles[i-1].close),
      Math.abs(candles[i].low - candles[i-1].close)
    );
    trSum += tr;
  }
  return trSum / candles.length;
}
function calculateRSI(prices) {
  if (prices.length < 2) return 50;
  let gains = 0, losses = 0, count = 0;
  for (let i = 1; i < prices.length; i++) {
    const diff = prices[i] - prices[i-1];
    if (diff > 0) gains += diff;
    else losses += Math.abs(diff);
    count++;
  }
  const avgGain = gains / count;
  const avgLoss = losses / count;
  const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
  return 100 - (100 / (1 + rs));
}
function calculateBollingerBands(prices, period, stdDev) {
  const sma = calculateSMA(prices, period);
  const std = Math.sqrt(prices.slice(-period).reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period);
  return {
    sma,
    upper: sma + (std * stdDev),
    lower: sma - (std * stdDev)
  };
}
function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  const fastEMA = calculateEMA(prices, fastPeriod);
  const slowEMA = calculateEMA(prices, slowPeriod);
  const macd = fastEMA - slowEMA;
  const signal = calculateEMA([macd], signalPeriod)[0];
  return { macd, signal };
}
function calculateEMA(prices, period) {
  const multiplier = 2 / (period + 1);
  let ema = prices[0];
  for (let i = 1; i < prices.length; i++) {
    ema = (prices[i] - ema) * multiplier + ema;
  }
  return ema;
}
function calculateIchimokuCloud(candles) {
  const tenkanSen = (Math.max(...candles.slice(-9).map(c => c.high)) + Math.min(...candles.slice(-9).map(c => c.low))) / 2;
  const kijunSen = (Math.max(...candles.slice(-26).map(c => c.high)) + Math.min(...candles.slice(-26).map(c => c.low))) / 2;
  const senkouSpanA = (tenkanSen + kijunSen) / 2;
  const senkouSpanB = (Math.max(...candles.slice(-52).map(c => c.high)) + Math.min(...candles.slice(-52).map(c => c.low))) / 2;
  return {
    tenkanSen,
    kijunSen,
    senkouSpanA,
    senkouSpanB
  };
}
function calculateFundamentalScore(fundamentalData) {
  let score = 50;
  // –£—á–∏—Ç—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
  if (fundamentalData.developerActivity) {
    if (fundamentalData.developerActivity > 100) score += 20;
    else if (fundamentalData.developerActivity > 50) score += 10;
    else if (fundamentalData.developerActivity < 20) score -= 15;
    else if (fundamentalData.developerActivity < 10) score -= 25;
  }
  // –£—á–∏—Ç—ã–≤–∞–µ–º —Å–æ—Ü–∏–∞–ª—å–Ω—ã–π —Å–µ–Ω—Ç–∏–º–µ–Ω—Ç
  if (fundamentalData.socialSentiment) {
    if (fundamentalData.socialSentiment > 70) score += 15;
    else if (fundamentalData.socialSentiment > 50) score += 5;
    else if (fundamentalData.socialSentiment < 30) score -= 15;
    else if (fundamentalData.socialSentiment < 10) score -= 25;
  }
  return Math.max(0, Math.min(100, score));
}
function calculateMarketSentiment(fearIndex, fundamentalScore) {
  // –£—Å—Ä–µ–¥–Ω—è–µ–º Fear & Greed Index –∏ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—É—é –æ—Ü–µ–Ω–∫—É
  return (fearIndex + fundamentalScore) / 2;
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π
// ==========================
async function checkOpenPositions(currentPrices) {
  for (const coin of globalState.watchlist) {
    const position = globalState.positions[coin.name];
    if (!position) continue;
    const currentPrice = currentPrices[coin.name];
    if (!currentPrice) continue;
    let shouldClose = false;
    let reason = '';
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç
    if (position.type === 'LONG' && currentPrice >= position.takeProfit) {
      shouldClose = true;
      reason = 'üéØ –î–æ—Å—Ç–∏–≥–Ω—É—Ç —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø—Ä–∏–±—ã–ª—å';
    } else if (position.type === 'SHORT' && currentPrice <= position.takeProfit) {
      shouldClose = true;
      reason = 'üéØ –î–æ—Å—Ç–∏–≥–Ω—É—Ç —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø—Ä–∏–±—ã–ª—å';
    }
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ø-–ª–æ—Å—Å
    if (position.type === 'LONG' && currentPrice <= position.stopLoss) {
      shouldClose = true;
      reason = 'üõë –°—Ä–∞–±–æ—Ç–∞–ª —Å—Ç–æ–ø-–ª–æ—Å—Å';
    } else if (position.type === 'SHORT' && currentPrice >= position.stopLoss) {
      shouldClose = true;
      reason = 'üõë –°—Ä–∞–±–æ—Ç–∞–ª —Å—Ç–æ–ø-–ª–æ—Å—Å';
    }
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø
    if (position.type === 'LONG' && currentPrice > position.entryPrice * 1.01) {
      position.trailingStop = Math.max(position.trailingStop || position.entryPrice, currentPrice * 0.99);
      if (currentPrice <= position.trailingStop) {
        shouldClose = true;
        reason = 'üìâ –¢—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø —Å—Ä–∞–±–æ—Ç–∞–ª';
      }
    } else if (position.type === 'SHORT' && currentPrice < position.entryPrice * 0.99) {
      position.trailingStop = Math.min(position.trailingStop || position.entryPrice, currentPrice * 1.01);
      if (currentPrice >= position.trailingStop) {
        shouldClose = true;
        reason = 'üìâ –¢—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø —Å—Ä–∞–±–æ—Ç–∞–ª';
      }
    }
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–º —Ä–∏—Å–∫–µ
    if (position.riskScore > 80) {
      shouldClose = true;
      reason = '‚ö†Ô∏è –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫-—Å–∫–æ—Ä ‚Üí –∑–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é';
    }
    if (shouldClose) {
      console.log(`‚úÖ –ó–ê–ö–†–´–¢–ò–ï: ${reason} –ø–æ ${coin.name}`);
      const tradeIndex = globalState.history.findIndex(t => t.coin === coin.name && t.status === 'OPEN');
      if (tradeIndex !== -1) {
        const trade = globalState.history[tradeIndex];
        trade.exitPrice = currentPrice;
        trade.profitPercent = position.type === 'LONG' 
          ? (currentPrice - trade.entryPrice) / trade.entryPrice 
          : (trade.entryPrice - currentPrice) / trade.entryPrice;
        trade.status = 'CLOSED';
        if (trade.profitPercent > 0) {
          globalState.stats.profitableTrades++;
          if (globalState.isRealMode) {
            // –í —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ –±–∞–ª–∞–Ω—Å –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ API
          } else {
            globalState.balance += (trade.size * trade.entryPrice * trade.profitPercent);
          }
        } else {
          globalState.stats.losingTrades++;
          if (globalState.isRealMode) {
            // –í —Ä–µ–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ –±–∞–ª–∞–Ω—Å –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ API
          } else {
            globalState.balance += (trade.size * trade.entryPrice * trade.profitPercent);
          }
        }
      }
      globalState.positions[coin.name] = null;
      globalState.marketMemory.consecutiveTrades[coin.name] = 0;
    } else {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Ç—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø
      if (position.type === 'LONG' && currentPrice > position.entryPrice * 1.01) {
        position.trailingStop = Math.max(position.trailingStop || position.entryPrice, currentPrice * 0.99);
      } else if (position.type === 'SHORT' && currentPrice < position.entryPrice * 0.99) {
        position.trailingStop = Math.min(position.trailingStop || position.entryPrice, currentPrice * 1.01);
      }
    }
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —É—Ä–æ–≤–Ω—è —Ä–∏—Å–∫–∞
// ==========================
function setRiskLevel(level) {
  globalState.riskLevel = level;
  // –ë–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Ä–µ–∂–∏–º–∞
  if (globalState.tradeMode === 'scalping') {
    // –î–ª—è —Å–∫–∞–ª—å–ø–∏–Ω–≥–∞ ‚Äî –±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–µ —Å—Ç–æ–ø—ã –∏ —Ç–µ–π–∫–∏
    globalState.scalpingSettings = {
      takeProfitPercent: 0.01, // +1%
      stopLossPercent: 0.005   // -0.5%
    };
  } else if (globalState.tradeMode === 'swing') {
    // –î–ª—è —Å–≤–∏–Ω–≥-—Ç–æ—Ä–≥–æ–≤–ª–∏ ‚Äî –±–æ–ª–µ–µ –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–µ
    globalState.scalpingSettings = {
      takeProfitPercent: 0.05, // +5%
      stopLossPercent: 0.03   // -3%
    };
  } else {
    // –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
    globalState.scalpingSettings = {
      takeProfitPercent: 0.03, // +3%
      stopLossPercent: 0.02   // -2%
    };
  }
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∏—Å–∫ –∏ –ø–ª–µ—á–æ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Ä–æ–≤–Ω—è
  switch(level) {
    case 'recommended':
      globalState.maxRiskPerTrade = 0.01; // 1%
      globalState.maxLeverage = 3;
      console.log('üìâ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –†–ï–ö–û–ú–ï–ù–î–£–ï–ú–´–ô —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: 1%, –ø–ª–µ—á–æ 3x');
      break;
    case 'medium':
      globalState.maxRiskPerTrade = 0.02; // 2%
      globalState.maxLeverage = 5;
      console.log('‚öñÔ∏è –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –°–†–ï–î–ù–ò–ô —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: 2%, –ø–ª–µ—á–æ 5x');
      break;
    case 'high':
      globalState.maxRiskPerTrade = 0.05; // 5%
      globalState.maxLeverage = 10;
      console.log('üöÄ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –í–´–°–û–ö–ò–ô —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: 5%, –ø–ª–µ—á–æ 10x');
      break;
    case 'extreme':
      globalState.maxRiskPerTrade = 0.10; // 10%
      globalState.maxLeverage = 20;
      console.log('üí• –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≠–ö–°–¢–†–ï–ú–ê–õ–¨–ù–´–ô —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: 10%, –ø–ª–µ—á–æ 20x (–û–ß–ï–ù–¨ –í–´–°–û–ö–ò–ô –†–ò–°–ö!)');
      break;
  }
  return globalState.riskLevel;
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –º–æ–Ω–µ—Ç—ã (–ò–°–ü–†–ê–í–õ–ï–ù–ê —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º)
// ==========================
async function getFundamentalData(coin) {
  const now = Date.now();
  const cacheKey = coin.name;
  const cacheDuration = 300000; // 5 –º–∏–Ω—É—Ç –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
  
  // –ï—Å–ª–∏ –µ—Å—Ç—å –∫—ç—à –∏ –æ–Ω –µ—â–µ –Ω–µ –∏—Å—Ç–µ–∫, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ
  if (globalState.fundamentalCache && 
      globalState.fundamentalCache[cacheKey] && 
      now - globalState.fundamentalCache[cacheKey].timestamp < cacheDuration) {
    console.log(`üíæ –ò—Å–ø–æ–ª—å–∑—É—é –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è ${coin.name}`);
    return globalState.fundamentalCache[cacheKey].data;
  }

  try {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫—ç—à, –µ—Å–ª–∏ –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–Ω
    if (!globalState.fundamentalCache) {
      globalState.fundamentalCache = {};
    }
    
    const response = await axios.get(`https://api.coingecko.com/api/v3/coins/${coin.name}`, {
      params: {
        localization: false,
        tickers: false,
        market_data: true,
        community_data: true,
        developer_data: true,
        last_updated: true
      },
      timeout: 10000
    });
    const data = response.data;
    const fundamentalData = {
      hashRate: null,
      activeAddresses: null,
      transactions: null,
      developerActivity: null,
      socialSentiment: null
    };

    if (data.market_data) {
      // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –∏—Å–ø–æ–ª—å–∑—É–µ–º sentiment_votes_up_percentage, –∞ –Ω–µ twitter_followers
      fundamentalData.socialSentiment = data.market_data.sentiment_votes_up_percentage || 50;
    }
    if (data.developer_data) {
      fundamentalData.developerActivity = data.developer_data.commits_30d || 0;
    }
    // –£–±—Ä–∞–Ω–æ: data.community_data.twitter_followers -> —ç—Ç–æ –Ω–µ–≤–µ—Ä–Ω–æ, —Ç–∞–∫ –∫–∞–∫ —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è market_data.sentiment

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –∫—ç—à
    globalState.fundamentalCache[cacheKey] = {
      data: fundamentalData,
      timestamp: now
    };
    globalState.marketMemory.fundamentalData[coin.name] = fundamentalData;
    return fundamentalData;

  } catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è ${coin.name}:`, error.message);
    // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞, –º–æ–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ
    if (globalState.fundamentalCache && globalState.fundamentalCache[cacheKey]) {
      console.log(`‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É—é —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è ${coin.name} –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ API`);
      return globalState.fundamentalCache[cacheKey].data;
    }
    return null;
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞
// ==========================
async function forceUpdateRealBalance() {
  console.log('üîÑ [–ë–ê–õ–ê–ù–°] –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞...');
  const balance = await getBingXRealBalance();
  if (balance !== null) {
    globalState.realBalance = balance;
    console.log(`‚úÖ [–ë–ê–õ–ê–ù–°] –ë–∞–ª–∞–Ω—Å –æ–±–Ω–æ–≤–ª—ë–Ω: $${balance.toFixed(2)}`);
  }
  return balance;
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ (–¥–ª—è –¥–µ–º–æ)
// ==========================
function deposit(amount) {
  if (amount <= 0) return false;
  globalState.balance += amount;
  console.log(`‚úÖ –ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ $${amount}. –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: $${globalState.balance.toFixed(2)}`);
  return true;
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ (–î–ï–ú–û ‚Üî –†–ï–ê–õ–¨–ù–´–ô)
// ==========================
function toggleMode() {
  globalState.isRealMode = !globalState.isRealMode;
  console.log(`üîÑ –†–µ–∂–∏–º –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω –Ω–∞: ${globalState.isRealMode ? '–†–ï–ê–õ–¨–ù–´–ô' : '–î–ï–ú–û'}`);
  if (globalState.isRealMode) {
    forceUpdateRealBalance();
  }
  return globalState.isRealMode;
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Ä–µ–∂–∏–º–∞ (adaptive, scalping, swing)
// ==========================
function toggleTradeMode() {
  const modes = ['adaptive', 'scalping', 'swing'];
  const currentIndex = modes.indexOf(globalState.tradeMode);
  const nextIndex = (currentIndex + 1) % modes.length;
  globalState.tradeMode = modes[nextIndex];
  // –ü—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ —Ä–µ–∂–∏–º–∞ ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞, –Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
  setRiskLevel(globalState.riskLevel);
  console.log(`‚ö° –¢–æ—Ä–≥–æ–≤—ã–π —Ä–µ–∂–∏–º –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω –Ω–∞: ${globalState.tradeMode}`);
  return globalState.tradeMode;
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –í—ã–≤–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
// ==========================
function printStats() {
  const s = globalState.stats;
  console.log(`
üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –¢–û–†–ì–û–í–õ–ò:`);
  console.log(`   –°–¥–µ–ª–æ–∫ –≤—Å–µ–≥–æ: ${s.totalTrades} (–ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö: ${s.profitableTrades}, —É–±—ã—Ç–æ—á–Ω—ã—Ö: ${s.losingTrades})`);
  console.log(`   Win Rate: ${s.winRate.toFixed(1)}%`);
  console.log(`   –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: $${s.totalProfit.toFixed(2)} (${((s.totalProfit / 100) * 100).toFixed(1)}%)`);
  console.log(`   –ú–∞–∫—Å. –ø—Ä–æ—Å–∞–¥–∫–∞: ${s.maxDrawdown.toFixed(1)}%`);
  console.log(`   –ú–∞–∫—Å. –ø–ª–µ—á–æ: ${s.maxLeverageUsed}x`);
  console.log(`   –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Ä—ã–Ω–∫–∞: ${s.volatilityIndex.toFixed(2)}%`);
  console.log(`   –†—ã–Ω–æ—á–Ω—ã–π sentiment: ${s.marketSentiment.toFixed(0)}%`);
  console.log(`   –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: $${globalState.balance.toFixed(2)}`);
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π –∫—Ä–∏–ø—Ç–æ—Ä—ã–Ω–∫–∞ (–Ω–∞ —Ä—É—Å—Å–∫–æ–º —Å üêÇ/üêª)
// ==========================
async function getCryptoNews() {
  try {
    const response = await axios.get('https://api.coinmarketcap.com/data-api/v3/cryptocurrency/listing?start=1&limit=10&sortBy=market_cap&sortType=desc&convert=USD&cryptoType=all&tagType=all&audited=false', {
      timeout: 10000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      }
    });
    if (!response.data || !Array.isArray(response.data.data.cryptoCurrencyList)) {
      throw new Error('Invalid response from CoinMarketCap');
    }
    const news = response.data.data.cryptoCurrencyList.slice(0, 5).map(coin => {
      const change24h = coin.quote.USD.percentChange24h;
      const trendEmoji = change24h > 0 ? 'üêÇ –ë—ã—á–∏–π' : 'üêª –ú–µ–¥–≤–µ–∂–∏–π';
      const trendClass = change24h > 0 ? 'positive' : 'negative';
      const russianNames = {
        'Bitcoin': '–ë–∏—Ç–∫–æ–∏–Ω',
        'Ethereum': '–≠—Ñ–∏—Ä–∏—É–º',
        'Solana': '–°–æ–ª–∞–Ω–∞',
        'Ripple': '–†–∏–ø–ª',
        'Dogecoin': '–î–æ–≥–µ–∫–æ–∏–Ω',
        'Cardano': '–ö–∞—Ä–¥–∞–Ω–æ',
        'Polkadot': '–ü–æ–ª–∫–∞–¥–æ—Ç',
        'Chainlink': '–ß–µ–π–Ω–ª–∏–Ω–∫',
        'Avalanche': '–ê–≤–∞–ª–∞–Ω—á',
        'Cosmos': '–ö–æ—Å–º–æ—Å',
        'Uniswap': '–Æ–Ω–∏—Å–≤–∞–ø',
        'Aave': '–ê–∞–≤–µ',
        'Filecoin': '–§–∞–π–ª–∫–æ–∏–Ω',
        'Litecoin': '–õ–∞–π—Ç–∫–æ–∏–Ω',
        'Algorand': '–ê–ª–≥–æ—Ä–∞–Ω–¥',
        'Near Protocol': '–ù–∏—Ä –ü—Ä–æ—Ç–æ–∫–æ–ª',
        'Aptos': '–ê–ø—Ç–æ—Å'
      };
      const russianName = russianNames[coin.name] || coin.name;
      return {
        title: `${russianName} (${coin.symbol}) ‚Äî –†—ã–Ω–æ—á–Ω–∞—è –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è: $${(coin.marketCap || 0).toLocaleString()}`,
        source: 'CoinMarketCap',
        sentiment: trendClass,
        trend: trendEmoji,
        change24h: change24h.toFixed(2),
        url: `https://coinmarketcap.com/currencies/${coin.slug}/`
      };
    });
    return news;
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π —Å CoinMarketCap:', error.message);
    return [
      { 
        title: "–ë–∏—Ç–∫–æ–∏–ΩÁ™ÅÁ†¥$60K, Êú∫ÊûÑËµÑÈáëÊåÅÁª≠ÊµÅÂÖ•", 
        source: "CryptoNews", 
        sentiment: "positive",
        trend: "üêÇ –ë—ã—á–∏–π",
        change24h: "+2.5%",
        url: "#"
      },
      { 
        title: "–≠—Ñ–∏—Ä–∏—É–º ETF Approval Expected in Q3 2024", 
        source: "CoinDesk", 
        sentiment: "positive",
        trend: "üêÇ –ë—ã—á–∏–π",
        change24h: "+1.8%",
        url: "#"
      },
      { 
        title: "–†—ã–Ω–æ–∫ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ—Ç—Å—è: –ê–ª—å—Ç–∫–æ–∏–Ω—ã —É–ø–∞–ª–∏ –Ω–∞ 15% –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ", 
        source: "Cointelegraph", 
        sentiment: "negative",
        trend: "üêª –ú–µ–¥–≤–µ–∂–∏–π",
        change24h: "-3.2%",
        url: "#"
      },
      { 
        title: "–°–µ—Ç—å Solana –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π", 
        source: "The Block", 
        sentiment: "positive",
        trend: "üêÇ –ë—ã—á–∏–π",
        change24h: "+4.1%",
        url: "#"
      },
      { 
        title: "–†–µ–≥—É–ª—è—Ç–æ—Ä–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –∫—Ä—É–ø–Ω—ã–µ –±–∏—Ä–∂–∏ —É—Å–∏–ª–∏–≤–∞–µ—Ç—Å—è", 
        source: "Bloomberg Crypto", 
        sentiment: "negative",
        trend: "üêª –ú–µ–¥–≤–µ–∂–∏–π",
        change24h: "-1.7%",
        url: "#"
      }
    ];
  }
}

// ==========================
// –§–£–ù–ö–¶–ò–Ø: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ API BingX (—Ä–µ–∞–ª—å–Ω–∞—è —Å–¥–µ–ª–∫–∞ —Å 30% —Ä–∏—Å–∫–æ–º)
// ==========================
async function testBingXAPI() {
  try {
    console.log('üß™ [–¢–ï–°–¢] –ù–∞—á–∏–Ω–∞—é —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ API BingX...');
    if (!BINGX_API_KEY || !BINGX_SECRET_KEY) {
      console.error('‚ùå [–¢–ï–°–¢] API-–∫–ª—é—á–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
      return { success: false, message: 'API-–∫–ª—é—á–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã' };
    }
    // –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å
    const balance = await getBingXRealBalance();
    if (balance === null) {
      console.error('‚ùå [–¢–ï–°–¢] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å');
      return { success: false, message: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å' };
    }
    // –®–∞–≥ 2: –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É BTC
    const btcPrice = await getCurrentPrices();
    const btcPriceValue = btcPrice.bitcoin || 62450.50;
    // –®–∞–≥ 3: –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ (30% –†–ò–°–ö–ê –æ—Ç –±–∞–ª–∞–Ω—Å–∞)
    const riskPercent = 0.3; // 30% —Ä–∏—Å–∫
    const stopLossPercent = 0.02; // 2% —Å—Ç–æ–ø-–ª–æ—Å—Å
    const riskAmount = balance * riskPercent;
    const stopDistance = btcPriceValue * stopLossPercent;
    const size = riskAmount / stopDistance;
    console.log(`üß™ [–¢–ï–°–¢] –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é LONG —Å —Ä–∏—Å–∫–æ–º 30% –æ—Ç –±–∞–ª–∞–Ω—Å–∞: $${riskAmount.toFixed(2)}`);
    // –®–∞–≥ 4: –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
    const result = await placeBingXFuturesOrder(
      'BTC',
      'BUY',
      'MARKET',
      size,
      null,
      3
    );
    if (result) {
      const fee = size * btcPriceValue * globalState.takerFee;
      const trade = {
        coin: 'bitcoin',
        type: 'LONG',
        size: size,
        entryPrice: btcPriceValue,
        currentPrice: btcPriceValue,
        leverage: 3,
        stopLoss: btcPriceValue * (1 - stopLossPercent),
        takeProfit: btcPriceValue * 1.04,
        fee: fee,
        timestamp: new Date().toLocaleString(),
        status: 'OPEN',
        orderId: result.orderId,
        progress: 0,
        probability: 50
      };
      globalState.history.push(trade);
      globalState.positions['bitcoin'] = trade;
      globalState.stats.totalTrades++;
      globalState.marketMemory.consecutiveTrades['bitcoin'] = (globalState.marketMemory.consecutiveTrades['bitcoin'] || 0) + 1;
      globalState.stats.maxLeverageUsed = Math.max(globalState.stats.maxLeverageUsed, 3);
      console.log('‚úÖ [–¢–ï–°–¢] –¢–µ—Å—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∞!');
      return { success: true, message: '–¢–µ—Å—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∞! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–∞—à —Ñ—å—é—á–µ—Ä—Å–Ω—ã–π —Å—á–µ—Ç –Ω–∞ BingX.' };
    } else {
      console.error('‚ùå [–¢–ï–°–¢] –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –æ—Ä–¥–µ—Ä –Ω–∞ BingX Futures');
      return { success: false, message: '–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –æ—Ä–¥–µ—Ä –Ω–∞ BingX Futures' };
    }
  } catch (error) {
    console.error('‚ùå [–¢–ï–°–¢] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ API BingX:', error.message);
    return { success: false, message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ API: ' + error.message };
  }
}

// ==========================
// –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø ‚Äî –¶–ò–ö–õ –ë–û–¢–ê
// ==========================
(async () => {
  console.log('ü§ñ –ó–ê–ü–£–°–ö –ë–û–¢–ê v20.0 ‚Äî –¢–†–ï–ô–î–ò–ù–ì –ë–û–¢ –í–ê–°–Ø 3000 –£–ù–ò–ö–ê–õ–¨–ù–´–ô (BINGX)');
  console.log('üìå deposit(—Å—É–º–º–∞) ‚Äî –ø–æ–ø–æ–ª–Ω–∏—Ç—å –¥–µ–º–æ-–±–∞–ª–∞–Ω—Å');
  console.log('üîÑ toggleMode() ‚Äî –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ä–µ–∂–∏–º (–î–ï–ú–û ‚Üî –†–ï–ê–õ–¨–ù–´–ô)');
  console.log('‚ö° toggleTradeMode() ‚Äî –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–æ—Ä–≥–æ–≤—ã–π —Ä–µ–∂–∏–º (adaptive, scalping, swing)');
  console.log('üí£ setRiskLevel() ‚Äî —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞ (recommended, medium, high, extreme)');
  console.log('üß™ testBingXAPI() ‚Äî –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ BingX (—Ä–µ–∞–ª—å–Ω–∞—è —Å–¥–µ–ª–∫–∞ —Å 30% —Ä–∏—Å–∫–æ–º)');
  
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞
  setRiskLevel('recommended');
  globalState.tradeMode = 'adaptive'; // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  
  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
  await forceUpdateRealBalance();
  
  while (globalState.isRunning) {
    try {
      console.log(`
[${new Date().toLocaleTimeString()}] === –ê–ù–ê–õ–ò–ó –û–¢ –í–ê–°–ò 3000 ===`);
      const fearIndex = await getFearAndGreedIndex();
      console.log(`üò± –ò–Ω–¥–µ–∫—Å —Å—Ç—Ä–∞—Ö–∞ –∏ –∂–∞–¥–Ω–æ—Å—Ç–∏: ${fearIndex}`);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
      if (Date.now() % 300000 < 10000) {
        await forceUpdateRealBalance();
      }
      
      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ —Ü–µ–Ω—ã
      const currentPrices = await getCurrentPrices();
      globalState.currentPrices = currentPrices;
      
      // –ü–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Å–µ—Ö –º–æ–Ω–µ—Ç —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
      for (const coin of globalState.watchlist) {
        await getFundamentalData(coin);
        // –ó–∞–¥–µ—Ä–∂–∫–∞ 1.5 —Å–µ–∫—É–Ω–¥—ã –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ –∫ CoinGecko –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è 429
        await new Promise(r => setTimeout(r, 1500)); 
      }
      
      // –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
      if (Date.now() % 1800000 < 60000) {
        globalState.marketMemory.news = await getCryptoNews();
        console.log('üì∞ –ü–æ–ª—É—á–µ–Ω—ã –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –∫—Ä–∏–ø—Ç–æ—Ä—ã–Ω–∫–∞');
      }
      
      await checkOpenPositions(currentPrices);
      
      let bestOpportunity = null;
      let bestReasoning = [];
      
      for (const coin of globalState.watchlist) {
        console.log(`
üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é ${coin.name}...`);
        const candles = await getBingXFuturesHistory(coin.symbol, '1h', 100);
        
        if (candles.length < 50) {
          console.log(`   ‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º ${coin.name} ‚Äî –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö`);
          await new Promise(r => setTimeout(r, 1200));
          continue;
        }
        
        const analysis = analyzeMarketWithAdaptiveStrategy(candles, coin.name, fearIndex, globalState.marketMemory.fundamentalData[coin.name]);
        
        if (!analysis || !analysis.signal.direction) {
          await new Promise(r => setTimeout(r, 1200));
          continue;
        }
        
        console.log(`   ‚úÖ –°–∏–≥–Ω–∞–ª –¥–ª—è ${coin.name}: ${analysis.signal.direction}`);
        analysis.signal.reasoning.forEach(r => console.log(`   ‚Ä¢ ${r}`));
        
        if (!bestOpportunity || analysis.signal.confidence > bestOpportunity.signal.confidence) {
          bestOpportunity = analysis;
          bestReasoning = analysis.signal.reasoning;
        }
        
        await new Promise(r => setTimeout(r, 1200));
      }
      
      if (bestOpportunity && (globalState.isRealMode || globalState.balance > 10)) {
        console.log(`
üíé –í–ê–°–Ø 3000 –†–ï–ö–û–ú–ï–ù–î–£–ï–¢: ${bestOpportunity.signal.direction} –ø–æ ${bestOpportunity.coin}`);
        bestReasoning.forEach(r => console.log(`   ‚Ä¢ ${r}`));
        const currentBalance = globalState.isRealMode ? (globalState.realBalance || 100) : globalState.balance;
        const riskAmount = currentBalance * globalState.maxRiskPerTrade;
        const price = bestOpportunity.currentPrice;
        const stopDistance = bestOpportunity.signal.direction === 'LONG' 
          ? price - bestOpportunity.signal.stopLoss 
          : bestOpportunity.signal.stopLoss - price;
        
        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ —Å —É—á–µ—Ç–æ–º —Ä–∏—Å–∫–∞
        const size = riskAmount / stopDistance;
        const finalSize = Math.max(0.001, size);
        
        console.log(`
üü¢ –í–•–û–î: ${bestOpportunity.signal.direction} ${finalSize.toFixed(6)} ${bestOpportunity.coin} —Å –ø–ª–µ—á–æ–º ${bestOpportunity.signal.leverage}x`);
        
        await openFuturesTrade(
          bestOpportunity.coin,
          bestOpportunity.signal.direction,
          bestOpportunity.signal.leverage,
          finalSize,
          bestOpportunity.currentPrice,
          bestOpportunity.signal.stopLoss,
          bestOpportunity.signal.takeProfit
        );
      } else {
        console.log(`
‚ö™ –í–∞—Å—è 3000 –Ω–µ –≤–∏–¥–∏—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π ‚Äî –æ—Ç–¥—ã—Ö–∞–µ–º...`);
      }
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É (–¥–ª—è –¥–µ–º–æ-—Ä–µ–∂–∏–º–∞)
      if (!globalState.isRealMode) {
        globalState.stats.totalProfit = globalState.balance - 100;
        if (globalState.balance > globalState.stats.peakBalance) {
          globalState.stats.peakBalance = globalState.balance;
        }
        globalState.stats.maxDrawdown = ((globalState.stats.peakBalance - globalState.balance) / globalState.stats.peakBalance) * 100;
      }
      
      globalState.stats.winRate = globalState.stats.totalTrades > 0
        ? (globalState.stats.profitableTrades / globalState.stats.totalTrades) * 100
        : 0;
      
      if (Date.now() % 60000 < 10000) {
        console.log(`
üí∞ ${globalState.isRealMode ? '–†–µ–∞–ª—å–Ω—ã–π' : '–î–µ–º–æ'}-–±–∞–ª–∞–Ω—Å: $${(globalState.isRealMode ? globalState.realBalance : globalState.balance)?.toFixed(2) || '–ó–∞–≥—Ä—É–∑–∫–∞...'}`);
        console.log(`üìä –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Ä—ã–Ω–∫–∞: ${globalState.stats.volatilityIndex.toFixed(2)}%`);
        console.log(`üß† –†—ã–Ω–æ—á–Ω—ã–π sentiment: ${globalState.stats.marketSentiment.toFixed(0)}%`);
      }
      
      if (globalState.stats.totalTrades > 0 && globalState.history.length % 2 === 0) {
        printStats();
      }
      
    } catch (error) {
      console.error('üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –í –¶–ò–ö–õ–ï:', error.message);
    }
    
    console.log(`
üí§ –ñ–¥—ë–º 60 —Å–µ–∫—É–Ω–¥ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞...`);
    await new Promise(r => setTimeout(r, 60000));
  }
})();

// ‚úÖ –≠–ö–°–ü–û–†–¢ –§–£–ù–ö–¶–ò–ô
module.exports = {
  globalState,
  deposit,
  toggleMode,
  toggleTradeMode,
  setRiskLevel,
  forceUpdateRealBalance,
  testBingXAPI,
  balance: () => globalState.balance,
  stats: () => globalState.stats,
  history: () => globalState.history
};

global.deposit = deposit;
global.toggleMode = toggleMode;
global.toggleTradeMode = toggleTradeMode;
global.setRiskLevel = setRiskLevel;
global.forceUpdateRealBalance = forceUpdateRealBalance;
global.testBingXAPI = testBingXAPI;
global.balance = () => globalState.balance;
global.stats = () => globalState.stats;
global.history = () => globalState.history;

console.log('\n‚úÖ –¢—Ä–µ–π–¥–∏–Ω–≥ –ë–æ—Ç –í–∞—Å—è 3000 –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—â–µ–Ω!');
console.log('‚ùó –í–ê–ñ–ù–û: –î–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏ –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º —Å—á–µ—Ç–µ –ø–µ—Ä–µ–≤–µ–¥–∏—Ç–µ USDT –Ω–∞ —Ñ—å—é—á–µ—Ä—Å–Ω—ã–π —Å—á–µ—Ç –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ BingX.');
console.log('–ò—Å–ø–æ–ª—å–∑—É–π toggleMode() –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –º–µ–∂–¥—É –î–ï–ú–û –∏ –†–ï–ê–õ–¨–ù–´–ú —Ä–µ–∂–∏–º–æ–º.');
console.log('–ò—Å–ø–æ–ª—å–∑—É–π toggleTradeMode() –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –º–µ–∂–¥—É –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º, —Å–∫–∞–ª—å–ø–∏–Ω–≥ –∏ —Å–≤–∏–Ω–≥ —Ä–µ–∂–∏–º–∞–º–∏.');
console.log('–ò—Å–ø–æ–ª—å–∑—É–π setRiskLevel(level) –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —É—Ä–æ–≤–Ω—è —Ä–∏—Å–∫–∞: recommended, medium, high, extreme.');
console.log('–ò—Å–ø–æ–ª—å–∑—É–π testBingXAPI() –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ BingX (—Ä–µ–∞–ª—å–Ω–∞—è —Å–¥–µ–ª–∫–∞ —Å 30% —Ä–∏—Å–∫–æ–º).');
console.log('‚ö†Ô∏è –í–ê–ñ–ù–û: –ù–∏–∫–∞–∫–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∏–π —Ç—Ä–µ–π–¥–∏–Ω–≥-–±–æ—Ç –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –ø—Ä–∏–±—ã–ª—å. –†–∏—Å–∫ –ø–æ—Ç–µ—Ä–∏ –≤—Å–µ—Ö —Å—Ä–µ–¥—Å—Ç–≤ 100%.');
